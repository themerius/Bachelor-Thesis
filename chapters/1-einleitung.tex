\chapter{Einleitung}

Sprache formt die Realität. Programmschöfper können diese Tatsache unmittelbar
in Aktion erleben, wie die Sprache die Realität des Computersystems verändert.
Wenn eine Sprache auf ein speziellen Aktionsraum definiert wird, kann die
Sprache für diesen Aktionsraum soweit abstrahiert werden, dass sie sehr
elegant und präzise die Probleme des Aktionsraum umschreiben und lösen kann.
Als \emph{domain-specific language (DSL)} bezeichnet man eine solche auf
einen spezifischen Aktionsraum, Wissensgebiet, Problemfeld oder Domäne
zugeschnittene Sprache.

\paragraph{Vorteile von DSLs}

\begin{itemize}
  \item DSLs sind ausdrucksstark
  \item DSLs sind prägnant
  \item DSLs haben einen hohen Abstraktionsgrad
  \item DSLs können ein besseres Ergebnis liefern
  \item DSL-basierte Entwicklung skaliert gut
\end{itemize}

(\cite{dsls} Seite 20f)

\paragraph{Nachteile von DSLs}

\begin{itemize}
  \item Sprachdesign ist schwierig
  \item DSLs haben gewisse Vorauskosten
  \item Der Einsatz von DSLs kann zu Performanzschwäche führen
  \item DSLs fehlen machmal die adäquate Werkzeugunterstützung
  \item „Wieder-eine-neue-Sprache-zu-lernen Syndrom“
  \item DSLs verführen zu sprachlicher Kakophonie\footnote{
        Kann entstehen durch den Einsatz verschiedenster
        Programmiersprachen bzw. DSLs die sich in verschiedene
        Richtungen entwickeln, wenn nicht ordentlich verwaltet, kann
        dies zu einer gewissen Anarchie führen kann.}
\end{itemize}

(\cite{dsls} Seite 21f)

\paragraph{Ablauf}\label{par-ablauf}

In dieser Thesis wird ein Vergleich zwischen zwei DSL-Technologien vorgenommen
und die Frage geklärt welche der Technologien die praktikablere Lösung für
den gestellten Anwendungsfall darstellt.
Das heißt also, dass innerhalb der Arbeit eine Entscheidung getroffen wird,
welche der beiden Technologien ausgewählt wird und in welcher somit
schlussendlich der Anwendungsfall als Prototyp umgesetzt wird.

Der Anwendungsfall bzw. Aktionsraum dieser so entstehenden Sprache ist ein
neuartiges Textsatzsystem, welches von \TeX~ inspiriert ist, jedoch auf
Webtechnologie zur Darstellung setzt.

\paragraph{Geplante Zeitaufwendung}

\begin{itemize}
  \item ca. $1\over{2}$ der Zeit für den Vergleich der Technologien,
  \item ca. $1\over{2}$ der Zeit für die Implementierung der DSL, sowie
        der Webtechnologie zur Darstellung.
        Wobei ein nicht unerheblicher Teil der Code-Snippets vom Technologievergleich
        auch in die eigentliche Implementierung einfließt.
\end{itemize}

\section{Vorgeschichte}

Die Idee, welche in Kapitel \ref{sec-idee} im Detail beschrieben ist,
entstammt der Zeit meines Praxissemesters am
\emph{Fraunhofer-Institut für Solare Energiesysteme ISE}.
Diese sind mit den Tools zur automatischen Dokumentengenerierung, insbesondere
für deren Jahresbericht, weniger zufrieden. Die gewünschten
Fähigkeiten müssen über mehrere Tools zusammenlaufen, welche nicht immer
ideal zusammenarbeiten; z.B. LaTeX plus Microsoft Word plus Python-Skripte.
Da mich diese Thematik interessiert, beschäftigte ich mich in meiner Freizeit
etwas damit und überlegte mir, wie ich diesem Umstand verbessern kann.

Wie schon erwähnt handelt es sich um ein Werkzeug, welches automatische
Dokumentengenerierung ermöglichen soll. Für diese oder ähnliche Aufgaben,
mit mehr oder weniger automatisierten Fähigkeiten,
gibt es bereits zahlreiche andere Werkzeuge wie z.B.:

\begin{itemize}
  \item \TeX~ bzw. \LaTeX,
  \item Word, OpenOffice,
  \item Google Docs,
  \item Markdown,
  \item \ldots
\end{itemize}

Jedes dieser Werkzeuge hat seine individuellen Vor- und Nachteile.
Aber diese Bachelor-Thesis will u.a. einen anderen Ansatz ausprobieren, und
seine Machbarkeit, Praxistauglichkeit und Weiterentwicklungsmöglichkeiten
feststellen bzw. überprüfen.

\paragraph{Diese Thesis will für den Anwendungsfall}

\begin{itemize}
  \item Potentiale dieser Idee bzw. Vision erkennen,
  \item Ein Proof of Concept erstellen,
  \item Weiterentwicklungsmöglichkeiten aufzeigen.
\end{itemize}

\section{Anwendungsfall: Idee und Vision}\label{sec-idee}

Wie wäre es, wenn als Dokument-Endprodukt eine mehr oder weniger
gewöhnliche HTML/CSS/JS-Webseite herauskommt?
Wenn dieses Endprodukt zudem vom Webbrowser aus \emph{passend} auf
DIN-A4-Seiten gedruckt oder als PDF gespeichert werden kann?

Wie wäre es, wenn als Dokumenten-\-Generator-\-Sprache eine \emph{vollwertige}
Programmiersprache zum Einsatz käme? Wenn diese Sprache zudem an die
Domänen\-gege\-ben\-heit, die durch den Willen ein Dokument zu verfassen,
angepasst ist?

\subsection{Gestalterische Fähigkeiten}

Mit Webtechnologien ist es möglich sehr flexible Layouts zu erstellen,
hochwertige Schriftarten einzusetzen und hat eine große Auswahl an
Technologien zu bieten, um z.B. Vektorgrafiken, Animationen oder
andere dynamische und statische Inhalte zu generieren und zu
präsentieren. Es gibt schon sehr viele aktive und geniale Javascript-Bibliotheken,
um Webseiten mit verschiedensten Dingen auszurüsten,
wie z.B. MathJAX\footnote{\url{http://www.mathjax.org}} oder
D3.js\footnote{\url{http://d3js.org}}.

All diese Webtechnologien sind durch die W3C Organisation standardisiert
und sind quasi schon ubiqutär, da nahezu jedes Gerät mittlerweile einen
Webbrowser hat. Die meisten Softwareentwickler oder auch
Gestalter sind mit diesen Technologien vertraut, zudem beschäftigen sich
Laien sehr oft auch mit Webtechnologie, allein weil sie z.B. eine kleine
eigene Webseite erstellen wollen.

Bündelung von verschiedenen Webdiensten wird ermöglicht, so könnte man sich
vorstellen bestimmte Informationen über z.B. die WolframAlpha-API
anzufordern oder verarbeiten zu lassen oder wenn es nur eine Verlinkung
als Metainformation ist. Zusammengefasst:

\begin{itemize}
  \item flexible Layouts und Gestaltungsmöglichkeiten,
  \item hochwertige Schriftarten verfügbar,
  \item leichte Erweiterbarkeit,
  \item viele Technologien,
  \item Standardisiert, sichere Weiterentwicklung → Zukunftssicherheit,
  \item ubiqutär eingesetzt → keine zusätzlichen Softwareinstallationen,
  \item sehr universelles Ausgabeformat → Webbrowser
        kann Webseiten z.B. auch in PDFs wandeln,
  \item bekannte Materie für viele Menschen,
  \item Verwendung verschiedener Dienste über Web-APIs.
\end{itemize}

\subsection{Interaktive Fähigkeiten}

Webtechnologien haben nicht nur die o.g. Fähigkeiten, sondern gerade
HTML5 glänzt mit seinen interaktiven Fähigkeiten, welche einem relativ
statischen Dokument zusätzliche Möglichkeiten bietet, Dinge zu
visualisieren und dennoch druckbar zu halten.

Die neuen visuellen Fähigkeiten sind nicht der einzge Vorteil der sich ergibt,
sondern der Benutzer kann auch viel mehr mit dem Dokument interagieren
und mit anderen Personen die in irgendeiner Form an dem Dokument beteiligt
sind, z.B. durch Kommentare bzw. Diskussionen direkt im Dokument,
kommunizieren.

Auch können Daten dynamisch nachgeladen werden, z.B. ein Plot der sich
im Dokument bei Änderungen oder neuen Daten automatisch aktualisieren kann.

Anreicherung mit Metadaten ist auch möglich, die Daten können dem Dokument
implizit mitgeliefert werden, so dass Metainformationen über ein Maus-Hover
eingeblendet werden oder eine extra Informationsbox aufgeht oder einfache
Querverweise, z.B. zur komfortablen Referenzierung auf Quellen,
auf andere Dokumente oder Internetadressen.

\subsection{Automatisierungs- und Programmierungsfähigkeiten}

Als Schnittstelle zur Erstellung eines Dokuments soll Programmcode
dienen, ähnlich wie es bei \LaTeX und Derivaten der Fall ist, nur
dass eben eine „vollwertige“ Programmiersprache zum Einsatz kommt, diese
dann viele neue Türen öffnet, um die Dokumentengenerierung weiter
zu automatisieren oder mit mehr dynamischen bzw. generierten Inhalten
zu füllen.

\emph{Die Plattform soll zur Kooperation zwischen verschiedensten
Funktionen, Programmen und Diensten dienen.}

Der Programmcode übernimmt auch Dinge wie die automatische Durchnummerierung
von Kapiteln, oder Auflösung von Querreferenzen auf Kapitel, Bilder oder
Literatur. Dadruch, dass es Programmcode ist, kann jedes beliebige Verhalten
hinzugefügt oder Vorhandenes modifiziert werden, so dass es auf die Anforderungen
des gewünschten, eventuell speziellen oder neuartigen, Dokumententypus
zugeschnitten werden kann.

Da es sich um normalen Programmcode handelt, ist es leicht möglich die
Best-Practices auch auf die Dokumentenerstellung zu übertragen.
Beispielsweise werden Versionierung und Zusammenarbeit erleichtert,
da Versionskontrollwerkzeuge wie \emph{git} eingesetzt werden können.

Als Grundlage dienen objektorientierte Paradigmen, was dem Programmcode
und damit auch dem Dokument-Code ermöglicht gut gegliedert und strukturiert
zu werden z.B. in Namenräume bzw. Pakete oder Klassen bzw. Objekte.

\paragraph{Szenario 1:} Integration von verschiedenen „Markup-Formaten“.
Die Programmierplattform könnte eine Bibliothek bereitstellen, mit der
man auch andere Markups laden und in das Dokument leicht integrieren
kann.

So könnte man sich vorstellen, dass ein Teil des Dokuments mit Markdown
geschrieben ist, ein anderer als html und wieder ein anderer in
restructuredtext. Die Bibliothek wandelt die verschiedenen Eingebeformate
auf einen gemeinsamen Nenner um.

\begin{verbatim}
Section('Ueberschrift')
Paragraph('Ein laengerer Text . . .')
SectionFromMarkdown('/home/kapitel_x.md')
Subsection('Unterueberschrift')
SectionFromRestructuredtext('/home/kapitel_y.rst')
Paragraph('Weiterer Text . . .')
\end{verbatim}

Weiter könnte man sich auch vorstellen, statt Markdown auch z.B. Word-Dokumente
umwandeln zu lassen, also Kapitel, Texte, Bilder etc. daraus zu extrahieren und so in
das Dokument einzupassen. → Jeder kann seine gewohnten Tools nutzen bzw.
Tools können kombiniert werden.

Oder die Wandlung von Datenstrukturen der Programmiersprache in eine passende
Dokumenten-Darstellung. So dass man beispielsweise komplexe Tabellen aus
Listen zusammenstellen kann und diese Listen können Resultate
verschiedener Regeln sein oder auch aus einer Quelle wie einer CSV-Datei
entstammen. Sprich man kann direkt mit der zu darstellenden Tabelle
rechnen, sie weiterverarbeiten oder anreichern und falls benötigt auch
mehrfach verwenden bzw. darstellen lassen.

Auf diese Art kann man verschiedenste Technologien kooperieren lassen und
auf einen Nennen bringen -- ohne dass die Qualität des Dokuments darunter
leider muss, da eine Formatierungssicherheit (Layout) vorliegt,
ähnlich wie es bei \LaTeX~ der Fall ist.

\paragraph{Szenario 2:} Immer wenn das Dokument „gebaut“ wird, kann z.B.
automatisch ein Skript angeworfen werden, welches einen Plot als Bild
anfertigt. Dieses Bild kann dann direkt in das resultierende Dokument ohne
Umwege eingebaut werden. Vorteil: Der Dokumenten-Ersteller muss also nicht jedes
mal wenn er den Plot modifiziert, ihn nochmals manuell anfertigen und
die Bilddatei erneut in das Dokument einpflegen. → Weniger Handarbeit,
die Dokumenten-Erstellungsumgebung muss nicht verlassen werden.

\paragraph{Szenario 3:} Durch eine vollwertige Programmiersprache hat
der Dokumenten-Ersteller Zugriff auf verschiedene Programm-Bibliotheken,
um z.B. Daten aus einer Datenbank oder dem Dateisystem zu holen und diese
zu verarbeiten, aufzubereiten und im Dokument darzustellen, beispielsweise
als Plot. → Zugriff auf immer aktuelle Daten, mit jeder Dokumenten-Erzeugung.

Weiter könnte man sich weiter vorstellen, statt einen direkten Datenbankzugriff
einen Zugriff über ein gewohntes Werkzeug wie Excel zu machen,
so dass ich als Dokumenten-Ersteller über meine gewohnte Excel-Abläufe
meine Daten zusammenstelle und die xls-Datei über den Programmcode einbinde.
Excel könnte so bei Bedarf geöffnet
werden, um neue Daten holen und eine aktualiserte xls-Datei ablegen. Die
Kommunikation könnte via VBScript ablaufen. → Einbettung
verschiedener Umgebungen.

\paragraph{Szenario 4:} Ermöglicht Konvertierung von verschiedenen
Konventionen auf einen gemeinsamen Nenner, z.B. bei chemischie Formeln
gibt es viele Konventionen der Repräsentation (populär sind u.a.
SMILES, Molfiles oder IUPAC-Namen.)
Eine Bibliothek könnte all diese Formate annehmen und
für die Webansicht konform machen.

Zudem könnte eine implizite Anreicherung der Informationen vorgenommen werden,
so dass der Benutzer im Programmcode lediglich programmatisch etwas wie
„Zeichne Strukturformel für Coffein“ angibt,
aber die Bibliothek noch weitere Hintergrundinformationen
zu Coffein aus anderen Quellen (z.B. Wikipedia, WolframAlpha, \ldots) bezieht
und dem Dokument hinzufügt.

\paragraph{Szenario 5:} Dokumentation
und lauffähiger Code vereint, so dass das Dokument quasi auch schon selbst
die Problemlösung errechnen kann.

Beispiel: Das Dokument beschreibt eine Simulation, zu einem gestellten
Problem. In dem Dokument selbst ist ein Algorithmus beschrieben, der
für die Simulation eingesetzt wird. Aber dadruch, dass das Dokument selbst
in einer vollständigen Programmiersprache geschrieben ist, kann dieser
Algorithmus direkt während der Dokumenten-Generierung ausgeführt werden
und z.B. mit Daten aus einer Datenbank gefüttert werden und entsprechende Plots
anfertigen um diese im resultierenden Dokument darzustellen.
Also ist der Code, der im Dokument beschrieben ist auch quasi gleichzeitg
der funktionsfähige und ausführbare Algorithmus, der Ergebnisse liefern kann.

\paragraph{Szenario 6:} Man könnte sogar so weit gehen, und statt eine einfache
zu HTML-Seite zu generieren einen kleinen Webserver über die
Programmierschnittstelle starten, welcher dem Dokument noch
mehr dynamische Fähigkkeiten ermöglicht, z.B. durch bidirektionale
Kommunikation zwischen Webbrowser-Client (Dokumenten-Betrachter) und
Dokumenten-Server. Das ermöglicht eine Interaktion zwischen Benutzer und
Dokument bzw. anderen Benutzern des Dokuments ermöglicht.

\subsection{Was getan werden muss}

Es muss also ein kleines JavaScript-Framework entwickelt werden, welches die
Aufgabe der Darstellung des Dokuments übernimmt. Die Zielachitektur.
Mehr dazu in Kapitel \ref{sec-zielarchitektur}.

Zudem braucht es noch ein Programm bzw. eine Programmiersprache, welche diese
Zielarchitektur füttern kann. Dieses Programm soll Aufgaben wie z.B.
Kapitel-Nummerierung automatisch abwickeln. Weiterhin muss es auch ein
wohlgeformte Schnittstelle zum Benutzer liefern. Diese Kriterien führen
dazu, dass die Entwicklung einer Domänen-Spezifischen Programmiersprache,
kurz DSL, sehr sinnvoll ist. Mehr dazu ist in Kapitel \ref{sec-dsl} zu finden.

\paragraph{Ziel} ist es also zu prüfen, ob es möglich und praktikabel ist
ein solches „\LaTeX~ on steroids“ zu erschaffen.

\section{Weitere Entwicklung}

Als ich die Machbarkeit als Bachelor-Thesis erkannte trug ich den
Vorschlag am ISE vor---jedoch sind
diese kein Informatik-Institut und sahen sich so nicht in der Lage die Arbeit
zu betreuen, wenngleich sie die Idee sehr nützlich finden. So wurde mir
nahe gelegt, dass ich doch bei einem anderen Fraunhofer-Institut anklopfen
könne.

So habe ich das \emph{Fraunhofer-Institut für Algorithmen und Wissenschaftliches
Rechnen SCAI} angeschrieben, und Dr. Marc Zimmermann fand
die Idee spannend und auch passend für deren Themengebiet. Sie bereiten u.a.
Patente auf indem sie eine Patent-PDF-Datei mit Hilfe ihres Java-Framework
zerlegen und die so erhaltenen Daten ggf. mit zusätzlichen Informationen
anreichern. Die Idee von mir hat ihnen sehr zugesagt, da sie noch eine
Möglichkeit suchten, die die aufbereiteten Patente mit Webtechnologie
darstellen kann, ohne ihre eigentliche Form bzw. Layout zu verlieren.

Damit dieses Projekt jedoch als Bachelor-Thesis bearbeitet werden darf,
muss ein Professor an der HTWG gefunden werden, dem das Thema auch gefällt
und die Betreuung dazu übernehmen will. So bin bin auf Prof. Dr. Marko
Boger zugengangen, der den Lehrstuhl für Software Architekturen an der HTWG
inne hat. Glücklicherweise konnte ich ihn überzeugen, dass das Thema auch
für ihn interessant ist dadruch, dass eine Entwicklung einer DSL Teil des
Projektes ist---jedoch wollte er noch einen Vergleich zwischen Xtext und Scala
dabei haben.
