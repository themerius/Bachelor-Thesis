\chapter{Lösungsweg}

In diesen Kapitel wird erörtert, welche Technologie (Xtext oder Scala) für
dieses am praktikabelsten ist und sich somit schlussendlich durchsetzt.
Kern hierfür ist die Übersicht in Form einer Vergleichsmatrix in Abschnitt
\ref{sec-vergleichsmatrix}.

\section{Vergleichsmatrix}\label{sec-vergleichsmatrix}

In dieser Tabelle soll eine Übersicht über den Vergleich gegeben werden, indem
die Fähigkeiten hervorgehoben werden und die Möglichkeiten von Xtext und
Scala (als interne DSL) gegenübergestellt werden. Dabei wird bei jeder
Fähigkeit bewertet, ob Xtext oder Scala die besseren Argumente liefert.
Zu beachten ist jedoch, dass die Bewertung auf das hier vorliegende Projekt
angepasst wurde. Die Bewertungen bzw. Gewichtungen müssen also
selbstverständlich für jedes Projekt und dessen Anforderungen individuell
angepasst werden.

Weiterhin gilt zu beachten, dass die Bewertungen ihrer Natur nach sowohl
\emph{intuitiv} als auch objektiv gewichtet werden. Jedoch steht am Ende
eine einigermaßen objektives Maß für die Möglichkeiten die einzelnen Lösungen
bieten, mit Blick auf das vorliegende Projekt.

Ich habe mich dazu entschieden eine Skala zwischen \emph{0 und 3}, wobei
0 schlechte Unterstützung/Möglichkeit/Funktion bzw. allgemein für das Projekt
ungeschickt bedeutet, zu verwenden.
Dabei ist ein Ergebnis zustande gekommen, indem sich \textbf{Scala mit 35 zu
29 Punkten in Vergleich mit Xtext} durchsetzt.
Somit ist für \emph{dieses} Projekt Scala besser geeignet.
Die detailierte Beschreibung folgt in den darauffolgenden Abschnitten.

\begin{landscape}
\begin{longtable}{|p{0.8cm}|p{4.4cm}|p{6.4cm}|p{6.4cm}|}

  \hline
  Kap. & Fähigkeit & Xtext (externe DSL) & Scala (interne DSL) \\ \hline \hline
  \endfirsthead

  \hline
  Kap. & Fähigkeit & Xtext (externe DSL) & Scala (interne DSL) \\ \hline
  \endhead

% Xtext man hat die moegliechkeit immerhin eine Lib zu benutzen
  & DSL als Library bzw. Deployment-möglichkeiten
  & Ist eine in sich mehr oder weniger geschlossene Struktur.
  & Interne DSL ist eine ganz normale Scala Library.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 1 } & \multicolumn{1}{c|}{ 3 } \\ \hline

  \ref{sec-infrastruktur}
  & Sprach-Infrastruktur
  & Xtext generiert automatisch ein speziell angepasstes Eclipse Plugin.
  & Alles wird mitgeliefert, wie z.B. Compiler, Built-Tools, REPL.
    Breite Unterstützung von vielen Editoren.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 3 } & \multicolumn{1}{c|}{ 3 } \\ \hline

  & Strukturierungsfähigkeit des Codes
  & Muss alles selbst gebaut werden. Vorteil: Es muss nur das nötigste
    umgesetzt werden.
  & Sämtliche Infrastruktur vorhanden. (Packages, Kontrollstrukturen,
    Build-Tools, ...)
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 1 } & \multicolumn{1}{c|}{ 3 } \\ \hline

  & DSL mit General Purpose mischbar
  & Hat viele Hürden, um eine DSL mehr Allgemeingültigkeit zu verpassen.
  & Alle Scala-Fähigkeiten nativ nutzbar, da die DSL eine normale Library ist.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 1 } & \multicolumn{1}{c|}{ 3 } \\ \hline

  & Toolsets (für DSL Gestaltung)
  & Komplette und entsprechend angepasste Eclipse Entwicklungsumgebung.
  & Die Sprache selbst, sonst keine Hilfen.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 3 } & \multicolumn{1}{c|}{ 0 } \\ \hline

  & Erweiterbarkeit durch Entwickler
  & Grammatik, Tests und Generator kann nach belieben wachsen, u.a.
    Unterstützung durch Eclipse.
  & Der Aufwand liegt bei der Entwicklung einer Library. Jedoch müssen
    Testumgebungen etc. selbst eingerichtet werden.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 3 } & \multicolumn{1}{c|}{ 2 } \\ \hline

  & Erweiterbarkeit durch Domain User/Community (z.B. für eigene Templates)
  & Es würde von dem Domain User verlangt werden BNF-Notation zu können,
    Xtend und er wäre auf Eclipse gezwungen. % da kann sich fast gar keine Community bilden
  & Einfache Scala Kenntnisse plus eine kleine Anleitung sollten ausreichen,
    die Bindings zu erstellen.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 0 } & \multicolumn{1}{c|}{ 3 } \\ \hline

  & Wiederverwendbarkeit bzw. Kombination mit Vorhandenem
  & Nur eingeschränkt, jedoch sind Grammatik Mixins möglich.
  & Sehr gut, da Library und mit Scalas Typ- und Vererbungssystem kann nach
    gewohnter Manier kombiniert und erweitert werden.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 1 } & \multicolumn{1}{c|}{ 2 } \\ \hline

  & Grammatikalische Gestaltung der DSL
  & Komplett frei und flexibel, da in BNF-Regeln definiert.
  & Eingeschränkt, man bleibt an Scala's Beschränkungen gebunden, aber
    dennoch sehr ausdrucksstarke Möglichkeiten.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 3 } & \multicolumn{1}{c|}{ 1 } \\ \hline

  & Generator: Zielplatform
  & Ohne Umwege kann jede Sprache oder Markup aus dem DSL-Modell durch eine
    Template-Engine generiert werden, das Eclipse-Plugin stellt sofort das
    Generat bereit. Jedoch kann nativer Code nicht direkt auf Xtext laufen,
    es muss also ggf. noch ein externer Build o.ä. angestossen werden.
  & Die DSL selbst kann direkt ein lauffähigkes Programm sein. Andere Ziele,
    z.B. andere Programmier-Sprachen oder Markup-Sprachen müssen einen Umweg
    über eine Template-Engine nehmen, allerdings steht hier ein Eclipse-Plugin
    bereit, welches direkt nach jeder Änderung das Generat bereitstellt; das
    Verfahren hierzu muss selbst entwickelt werden (das kann ein Vor- oder
    auch ein Nachteil sein.)
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 3 } & \multicolumn{1}{c|}{ 3 } \\ \hline

  \ref{sec-generator}
  & Generator: Möglichkeiten der Template-Engine
  & Xtend eine speziell angepasste DSL-Generator-Template-Engine.
    Die BNF-Grammatik wird transparent in Java- bzw. Xtend-Klassen übersetzt,
    mit denen das Ziel über das Template generiert werden kann.
  & 1. Freie Wahl, z.B. einface Multiline-Strings, Scala XML oder Scalate;
    wie aus der internen DSL das Ziel generiert wird, benötigt in der Regel
    einen Zwischenschritt (Bindings), welcher programmiert werden muss.
    Scala kann jedoch ggf. das Generat als Unterprogramm ausführen.
    2. Die interne DSL ist selbst lauffähig.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 3 } & \multicolumn{1}{c|}{ 2 } \\ \hline

  & Entwicklungsaufwand (u.a. Zeit, Einarbeitung)
  & Wenn BNF-Kenntnisse (th. Informatik) vorhanden sind, leichte Einarbeitung.
    Die Tools nehmen die harte Arbeit ab. Es gibt schon standardisierte
    Vorgehensweisen, z.B. wie der Generator gebaut wird.
  & Wenn Scala-Kenntnisse vorhanden, ist es mehr oder weniger die Entwicklung
    einer Library. Wie man den Generator baut, muss allerdings überlegt werden.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 2 } & \multicolumn{1}{c|}{ 2 } \\ \hline

  & Software-Lebenszyklus und Wartbarkeit
  & Dank IDE und einer schon eingerichteten Testumgebung, also sehr gut.
  & Man hat alle Möglichkeiten, die die Scala-Welt bietet, also sehr gut.
    Jedoch ist Handarbeit nötig.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 2 } & \multicolumn{1}{c|}{ 2 } \\ \hline

  & Skalierbarkeit, Umbebungs-Einlagerung
  & Kommt auf das Generat an. Man ist und bleibt an Eclipse gebunden.
  & Scala selbst ist in alle Richtungen (Größe, Nebenläufigkeit) sehr gut
    skalierbar.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 1 } & \multicolumn{1}{c|}{ 3 } \\ \hline

  & Umbebungs-Einlagerung
  & De facto Eclipse-Bindung, aber mit individuell angepasstem Eclipse-Plugin,
    welches sich mit dem Projektverlauf automatisch mit anpassen kann.
    Wenn das Ziel ein Arbeitsplatz-Front-End ist, sehr vorteilhaft -- sofern
    Eclipse eingesetzt werden will.
  & Kann gut in alle möglichen Szenarien eingebettet werden, Benutzung
    innerhalb eines Frameworks möglich, oder einsatz als Bibliothek,
    Stand-Alone oder in einer Entwicklungsumgebung wie Eclipse denkbar.
    Kann also quasi in eine beliebige Umgebung eingebettet werden
    wo eine JVM läuft oder auch als Service bereitgestellt werden.
    Allerdings ist Xtext in Eclipse besser eingebunden, da speziell angepasst.
  \\
  \cline{3-4}
  & & \multicolumn{1}{c|}{ 2 } & \multicolumn{1}{c|}{ 3 } \\ \hline

\end{longtable}
\newpage
\end{landscape}


\subsection{Sprach-Infrastruktur}\label{sec-infrastruktur}

\paragraph{Xtext} wird direkt als fertig eingerichtete Eclipse IDE
ausgeliefert, die speziell an die Erstellung von externen DSLs angepasst
ist. Es ist also ein DSL-Erstellungs-Ecosystem out-of-the-box geliefert,
um es mit vielen Anglezismen zu umschreiben.

Xtext bietet die folgenden Dinge, mit einer exzellenten IDE Unterstützung:

\begin{itemize}
  \item Grammatik DSL (BNF-ähnlich),
  \item unterschiedliche Code-Generatoren (siehe. Abschnitt \ref{sec-generator}),
  \item an DSL-Entwicklung angepasste Testumgebung (z.B. Unittests.)
\end{itemize}

Zudem sei erwähnt, dass Xtext aus den Grammatik-Regeln automatisch ein
passendes Eclipse-Plugin generiert, welches die Grammatik vollständig
unterstützt, wie z.B. Syntax-Hervorhebung, Überprüfung der grammatikalischen
Korrektheit oder Auto-Vervollständigung.

Weiter werden aus den Grammatik-Regeln Java-Klassen abgeleitet, mit denen
komfortabel die Code-Generierung vorgenommen werden kann. Der DSL-Programmierer
muss sich also nicht mit abstrakten Syntaxbäumen oder Ähnlichem herumschlagen.

\paragraph{Scala} bringt als vollwertige \emph{General Purpose Language}
ein umfangreiches Ökosystem mit, bestehend aus verschiedenen Werkzeugen
und vielen Bibliotheken, beispielsweise eine mächtige Standard-Bibliothek.
Hervorzuheben sind:

\begin{itemize}
  \item Linker und Compiler,
  \item Built-Tools wie \emph{sbt} mit Abhängigkeits-Management,
  \item Read-Evaluate-Print-Loop (REPL), interaktive Scala-Sitzung,
  \item Zugriff auf die Java-Standard-Library,
  \item Umfangreiche Scala-Standard-Library.
\end{itemize}

Darüber hinaus hat Scala sehr gute Fähigkeiten zur Erstellung von internen
DSLs, dies manifestiert sich in folgenden Fähigkeiten:

\begin{itemize}
  \item Unicode-Zeichen in Identifiern erlaubt,
  \item Methoden können als Prefix, Infix oder Postfix Operatoren dienen,
  \item viel syntaktischer Zucker u.a. mit impliziten Erweiterungen,
  \item Stärken von objektorientierter- und funktionaler-Programmierung
        geschickt vereint,
  \item starke statische Typesierung, jedoch ergänzt der Compiler selbstständig
        sehr viele Typ-Informationen.
\end{itemize}


\subsection{Generator: Möglichkeiten der Template-Engine}\label{sec-generator}

\paragraph{Xtext} hat zwei unterschiedliche Möglichkeiten ein
Generat zu erstellen, zum einen den \emph{Code Generator mit Xtend},
zum anderen den \emph{ModelInferrer mit Xbase}.

Der Code Generator stellt eine Template-Engine bereit, mit der
ein beliebiges Ziel erstellt werden kann, also z.B. C++, XML oder Java.
Dies wird dadurch erreicht, dass via Xtend aus Java-Klassen die aus der
Grammatik von Xtext automatisch generiert wurden ein Template zusammengebaut
werden kann. Man kann also förmlich die DSL entpacken und in ein Template
gießen.
Jedoch muss, je nach Generat, es ggf. kompiliert werden. Der
Domain-Benutzer hat keinen Zugriff auf z.B. Typ-Prüfung der JVM --
das Eclipse-Plugin überprüft lediglich die DSL auf ihre
grammatikalische Korrektheit. Man ist also komplett in der DSL eingesperrt.
Sehr gut also für nicht-JVM-Ziele, die einen striken Geltungsbereich mit
klar definierter DSL-Vokablen aufweisen. Kurz: Keine Unterstützung für
Expressions.

Der ModelInferrer zielt direkt auf die JVM bzw. Java ab und ermöglicht es
u.a. JVM-Datentypen direkt mit in die DSL einzubetten, mit allen Möglichkeiten
die Xbase\footnote{Wobei Xbase selbst mit Xtext gebaut wurde.}
bietet. Es können also dynamisch Java-Klassen erstellt werden und innerhalb
der DSL Fokus auf das Wesentliche gelegt werden und nur dort General Purpose
zugelassen werden, wo es auch wirklich benötigt wird.
Wobei es anzumerken gilt, dass das nicht ganz transparent geschieht,
es muss ein ModelInferrer geschrieben werden.
Sehr gut also, wenn das Ziel auf Java abgebildet werden soll und gewollt wird
dass auf Java-Klassen (wie z.B. java.io.File) aus der DSL heraus
zugegriffen werden kann. Kurz: Unterstützung für Expressions.
Die so entstehende Java-Dateien müssen aber auch noch vom Domain-Benutzer
kompiliert werden.\cite{xtext}

\paragraph{Scala} hingegen hat die Qual der Wahl was das Templating angeht.
Scala selbst bietet in der Standard-Bibliothek schon
eine Reihe an Möglichkeiten an,
z.B. Multiline-Strings oder XML. Jedoch muss sich der Programmierer ersteinmal
eine Architektur überlegen, wie er von den DSL-Klassen auf die Template-Engine
kommt. Weiterhin muss er auch festlegen, wie er das Resultat behandelt,
z.B. wo es gespeichert wird, welche Dateinamen es bekommt etc.
Allerdings hat man in der automatisierung mehr Werkzeuge in der Hand,
die insbesondere unabhängig von Eclipse sind. So könnte man sich vorstellen
nach dem generieren direkt einen Kompelierungsschritt anzuschließen und
danach das Kompelat auszuführen.

Der große Vorteil einer internen DSL ist jedoch, dass der DSL-Code auch
direkt als Programm laufen kann -- also komplett ohne Umwege, ohne Generierung.
Zudem kann man von der sehr hohen Freiheit und Flexibilität profitieren,
wobei u.U. viel Handarbeit nötig ist.

